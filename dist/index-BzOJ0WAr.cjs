"use strict";const l=require("./index-Dfqe4I64.cjs"),S=require("@bitcoinerlab/secp256k1"),y=require("bitcoinjs-lib"),u=require("sats-connect"),w=require("./BrowserWalletSigningError-CXaOQVy_.cjs"),O=require("./utils-BCPFyPtI.cjs");function C(r){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(r){for(const e in r)if(e!=="default"){const s=Object.getOwnPropertyDescriptor(r,e);Object.defineProperty(t,e,s.get?s:{enumerable:!0,get:()=>r[e]})}}return t.default=r,Object.freeze(t)}const F=C(S),h={mainnet:u.BitcoinNetworkType.Mainnet,testnet:u.BitcoinNetworkType.Testnet,signet:u.BitcoinNetworkType.Signet};y.initEccLib(F);async function W(r,t="mainnet"){const e=[],s=n=>{if(!n||!n.addresses||n.addresses.length!==2)throw new w.BrowserWalletSigningError("Failed to retrieve addresses using selected wallet");n.addresses.forEach(o=>{const d=l.getAddressFormat(o.address,t);let i=o.publicKey;d==="taproot"&&(i=O.fromXOnlyToFullPubkey(o.publicKey)),e.push({publicKey:i,address:o.address,format:d})})},c=()=>{throw new w.BrowserWalletRequestCancelledByUserError},a={payload:{purposes:["ordinals","payment"],message:"Provide access to Payment address and Ordinals address",network:{type:h[t]}},getProvider:r,onFinish:n=>s(n),onCancel:c};return await u.getAddress(a),e}async function P(r,t,{finalize:e=!0,extractTx:s=!0,network:c,inputsToSign:a}={network:"mainnet",inputsToSign:[]}){if(!e&&s)throw new l.BrowserWalletExtractTxFromNonFinalizedPsbtError;if(!t||!c||!a.length)throw new l.OrditSDKError("Invalid options provided");let n,o=null;const d=B=>{const{psbtBase64:p}=B;if(!p)throw new w.BrowserWalletSigningError("Failed to sign psbt using selected wallet");const g=y.Psbt.fromBase64(p);if(e&&a.forEach(f=>{f.signingIndexes.forEach(E=>{try{g.finalizeInput(E)}catch(m){throw console.error("Sign psbt error",m),new l.OrditSDKError("Failed to finalize input")}})}),s){try{n=g.extractTransaction().toHex()}catch(f){throw f instanceof Error&&f.message==="Not finalized"?new l.BrowserWalletExtractTxFromNonFinalizedPsbtError:new l.OrditSDKError("Failed to extract transaction from PSBT")}o=null}else n=g.toHex(),o=g.toBase64()},i=()=>{throw new w.BrowserWalletRequestCancelledByUserError},b={payload:{network:{type:h[c]},message:"Sign PSBT",psbtBase64:t.toBase64(),broadcast:!1,inputsToSign:a},onFinish:d,onCancel:i,getProvider:r};return await u.signTransaction(b),{hex:n,base64:o}}async function T(r,t,e,s="mainnet"){if(!t||!s||!e)throw new l.OrditSDKError("Invalid options provided");let c,a=null;const n=i=>{if(!i)throw new w.BrowserWalletSigningError("Failed to sign message using selected wallet");c=l.Buffer.from(i,"base64").toString("hex"),a=i},o=()=>{throw new w.BrowserWalletRequestCancelledByUserError},d={payload:{network:{type:h[s]},message:t,address:e},getProvider:r,onFinish:n,onCancel:o};return await u.signMessage(d),{hex:c,base64:a}}exports.satsConnectWalletGetAddresses=W;exports.satsConnectWalletSignMessage=T;exports.satsConnectWalletSignPsbt=P;
